# main_agent.py

import asyncio
import uuid
import os
import json
from typing import Dict, Any

from google.adk.agents import LlmAgent, SequentialAgent
from google.adk.agents.callback_context import CallbackContext
from google.adk.sessions import InMemorySessionService
from google.adk.runners import Runner
from google.genai.types import Content, Part
from app.core.config import settings
from .utils import BigQueryReader, bigquery_metdata_extraction_tool
from .prompt import (
    QUERY_UNDERSTANDING_INSTRUCTION,
    QUERY_GENERATION_INSTRUCTION,
    QUERY_REVIEW_REWRITE_INSTRUCTION,
    QUERY_EXECUTION_INSTRUCTION,
)
import logging
import traceback

# --- Basic Setup ---
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# --- Constants ---
APP_NAME = "sql_pipeline_app"
USER_ID = "dev_user_01"

bq_reader = BigQueryReader(project_id=settings.GOOGLE_CLOUD_PROJECT_ID, service_account_key_path=settings.BIGQUERY_SERVICE_ACCOUNT_KEY_PATH)

def initialize_state_var(callback_context: CallbackContext):
    """Callback to initialize the session state before the pipeline runs."""
    callback_context.state["PROJECT"] = settings.GOOGLE_CLOUD_PROJECT_ID # "hackathon-agents"
    callback_context.state["BQ_LOCATION"] = settings.BQ_LOCATION #"us-central1"
    callback_context.state["DATASET"] = settings.BQ_DATASET # "StyleHub"
    callback_context.state["bigquery_metadata"] = bigquery_metdata_extraction_tool()
    logger.info("Session state initialized with BigQuery project, location, and metadata.")

# Agent 1: Understands the user's query
query_understanding_agent = LlmAgent(
    name="query_understanding_agent",
    model=settings.BQ_AGENT_GEMINI_MODEL,
    instruction=QUERY_UNDERSTANDING_INSTRUCTION,
    output_key="query_understanding_output"
)

# Agent 2: Generates the initial SQL query
query_generation_agent = LlmAgent(
    name="query_generation_agent",
    model=settings.BQ_AGENT_GEMINI_MODEL,
    instruction=QUERY_GENERATION_INSTRUCTION,
    output_key="query_generation_output"
)

# Agent 3: Reviews and refactors the SQL
query_review_rewrite_agent = LlmAgent(
    name="query_review_agent",
    model=settings.BQ_AGENT_GEMINI_MODEL,
    instruction=QUERY_REVIEW_REWRITE_INSTRUCTION,
    output_key="query_review_rewrite_output"
)

# Agent 4: Executes the query
# This agent's primary job is to format the input for the tool call.
query_execution_agent = LlmAgent(
    name="query_execution_agent",
    model=settings.BQ_AGENT_GEMINI_MODEL,
    instruction=QUERY_EXECUTION_INSTRUCTION,
    tools=[bq_reader.execute_query],
    output_key="query_execution_output"
)

# The complete sequential pipeline
sql_pipeline_agent = SequentialAgent(
    name="SQLPipelineAgent",
    sub_agents=[
        query_understanding_agent,
        query_generation_agent,
        query_review_rewrite_agent,
        query_execution_agent,
    ],
    before_agent_callback=initialize_state_var,
)

# Session Service Setup
_session_service = InMemorySessionService()

async def call_bq_agent(user_query: str) -> Dict[str, Any]:
    """
    Executes the complete BigQuery SQL generation and execution pipeline asynchronously.

    The function follows these steps:
    1. Creates a session for the user's query.
    2. Initializes a Runner with the SQL pipeline agent.
    3. Runs the SQL pipeline agent asynchronously to process the user's query.
    4. Extracts the output from each stage of the pipeline (query understanding, SQL generation, SQL review, and query execution).
    5. Returns the results from each stage.

    Args:
        user_query (str): A natural language query about the data.
                          Example: "Show me the top 10 products by sales."

    Returns:
        dict: A dictionary containing the results from each stage of the pipeline.
            - 'user_query' (str): The original user's query.
            - 'understanding' (str): The output from the query understanding agent.
                                     If not generated, returns "Not generated."
            - 'generated_sql' (str): The SQL query generated by the SQL generation agent.
                                     If not generated, returns "Not generated."
            - 'reviewed_sql' (str): The SQL query reviewed and potentially rewritten by the SQL review agent.
                                    If not generated, returns "Not generated."
            - 'execution_result' (Any): The results of the executed query.
                                        If not executed, returns "Not executed."
            - 'error' (str, optional): An error message if the pipeline execution fails.
    """
    try:
        current_session_id = str(uuid.uuid4())
        print(f"▶️  Running SQL pipeline for query: '{user_query[:50]}...'")

        await _session_service.create_session(
            app_name=APP_NAME, user_id=USER_ID, session_id=current_session_id
        )

        runner = Runner(
            agent=sql_pipeline_agent,
            app_name=APP_NAME,
            session_service=_session_service,
        )

        initial_message = Content(role="user", parts=[Part(text=user_query)])

        async for _ in runner.run_async(
            user_id=USER_ID, session_id=current_session_id, new_message=initial_message
        ):
            pass  # Wait for the runner to complete

        session_state_data = await _session_service.get_session(
            app_name=APP_NAME, user_id=USER_ID, session_id=current_session_id
        )

        # Extract the output from each step using the defined output_keys
        understanding_output = session_state_data.state.get("query_understanding_output")
        generated_sql = session_state_data.state.get("query_generation_output")
        reviewed_sql = session_state_data.state.get("query_review_rewrite_output")
        execution_result = session_state_data.state.get("query_execution_output")

        print("understanding_output:>",understanding_output)
        print("generated_sql:>",generated_sql)
        print("reviewed_sql:>",reviewed_sql)
        print("execution_result:>",execution_result)


        print("✅ SQL pipeline completed successfully.")
        return {
            "user_query": user_query,
            "understanding": understanding_output or "Not generated.",
            "generated_sql": generated_sql or "Not generated.",
            "reviewed_sql": reviewed_sql or "Not generated.",
            "execution_result": execution_result or "Not executed.",
        }

    except Exception as e:
        print(f"❌ Pipeline failed with an error: {e}")
        traceback.print_exc()
        return {"error": str(e)}

# --- Example Usage ---
async def main():
    """Main function to demonstrate running the SQL pipeline."""
    print("--- Running SQL Pipeline Agent ---")
    
    user_input = "what are the products with cost price more than 100?"
    
    result = await execute_sql_pipeline(user_input)

    print("\n--- PIPELINE RESULTS ---")
    if result.get("error"):
        print(f"Error: {result['error']}")
    else:
        # Pretty print the results
        for key, value in result.items():
            print(f"\n--- {key.replace('_', ' ').upper()} ---")
            if isinstance(value, (dict, list)):
                print(json.dumps(value, indent=2))
            else:
                print(value)
    print("------------------------")


if __name__ == "__main__":
    asyncio.run(main())
