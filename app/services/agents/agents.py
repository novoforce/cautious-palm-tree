from google.adk.agents import Agent, LoopAgent, SequentialAgent
from app.core.dependencies import get_bigquery_reader
from app.services.agents.agents_tools import get_similar_tables_tool, exit_loop,call_external_tell_time_agent,call_external_greeting_agent 

from google.adk.tools.function_tool import FunctionTool # Import FunctionTool


bq_rdr= get_bigquery_reader()
MODEL_GEMINI_2_0_FLASH="gemini-2.0-flash-live-001"

sql_generator_agent = Agent(
        model=MODEL_GEMINI_2_0_FLASH,
        name="sql_generator_agent",
        description="Handles the generation of SQL queries based on user requests.",
        instruction="""You are the Bigquery compatible SQL agent. Your task is to generate SQL queries based on user requests. Use the 'get_similar_tables_tool' tool to get access to the metadata of the database and generate SQL queries accordingly. 
        Do not perform any other actions.
        The SQL queries you generate should be compatible with BigQuery syntax.
        
        ## SQL Query Format
        - Use BigQuery compatible SQL syntax.
        - Example:
            - **User Query**: "How many users are there in the dataset?"
            - **SQL Query**: `SELECT count(*) FROM bigquery-public-data.thelook_ecommerce.users`
            - Ensure the SQL query is well-formed and executable in BigQuery.
        If the user asks for similar tables, use the 'get_similar_tables_tool' to retrieve relevant tables and their metadata.
        """,
        tools=[get_similar_tables_tool],
        output_key="sql_query",)

sql_executor_agent = Agent(
        model=MODEL_GEMINI_2_0_FLASH,
        name="sql_executor_agent",
        description="Handles the execution of SQL queries and returns results.",
        instruction="""You are the Bigquery compatible SQL executor agent. Your task is to execute the generated SQL queries. 
        #GENERATED SQL QUERY:> {{sql_query}}
        Use the 'bq_rdr.execute_query' tool to execute the SQL queries on Bigquery and get the result.
        """,
        tools=[bq_rdr.execute_query],
        output_key="sql_execution_result",
        include_contents='none'
    )

sql_refiner_agent = Agent(
        model=MODEL_GEMINI_2_0_FLASH,
        name="sql_refiner_agent",
        description="Handles the refinement/correction of SQL queries and returns the refined query.",
        instruction="""You are the Bigquery compatible SQL refiner agent. Your task is to refine the SQL queries generated by the 'sql_generator_agent'.
        You will be provided with the original SQL query and the SQL execution result.
        #ORIGINAL SQL QUERY:> {{original_sql_query}}
        If the SQL execution result is empty or indicates an error, refine the SQL query to correct it.
        If the SQL execution result is valid, return the original SQL query as it is and call the 'exit_loop' tool to end the iterative process.
        
        #SQL EXECUTION RESULT:> {{sql_execution_result}}
        """,
        tools=[exit_loop],
        output_key="sql_query",
    )

from pydantic import BaseModel, Field

class SQLOutput(BaseModel):
    final_sql: str = Field(description="The final SQL query after refinement.")
    sql_results: list = Field(default_factory=list, description="The results of the SQL query execution.")

sql_extractor_agent = Agent(
        model=MODEL_GEMINI_2_0_FLASH,
        name="sql_extractor_agent",
        description="Handles the extraction of the SQL query from the SQL execution result.",
        instruction="""You are the Bigquery SQL extractor. Your task is to extract the SQL query from the SQL execution result.
        You will be provided with the SQL execution result.
        
        #Following are the SQL and its results:> 
        {{sql_query}}
        {{sql_execution_result}}
        """,
        output_schema=SQLOutput,
        output_key="output",
        include_contents='none'
    )

refinement_loop = LoopAgent(
    name="RefinementLoop",
    sub_agents=[
        sql_executor_agent,
        sql_refiner_agent,
    ],
    max_iterations=5 # Limit loops
)

root_sql_agent = SequentialAgent(
    name="SequentialLoopPipeline",
    sub_agents=[
        sql_generator_agent, # Run first to create initial doc
        refinement_loop,# Then run the critique/refine loop
        sql_extractor_agent
    ],
    description="Generate the SQL query based on user request, execute it, and refine it iteratively until the query is correct or no further refinements are needed",
)

general_agent = Agent(
    # A unique name for the agent.
    name="serena",
    model=MODEL_GEMINI_2_0_FLASH,
    description="General conversation agent",
    instruction=f"""
    # Jarvis: The Helpful Assistant
        You are Jarvis, a helpful assistant capable of healthy conversation and resolving queries related to databases using the appropriate tools provided. Follow these guidelines:
        - **root_sql_agent**: Handles database-related queries, generating SQL queries, executing them, and refining them iteratively.

        ## Query Analysis
        - For database-related queries, delegate to **root_sql_agent**.
        - If the query does not fit any of the above categories, respond with a friendly message indicating that you can assist with database-related queries or greetings/farewells.
        - For list table database-related queries, invoke 'bq_rdr.list_tables_in_dataset' tool to get the list.

        ## Conversation Closure
        - Aim to end every interaction on a positive note.
    """,
    tools=[bq_rdr.list_tables_in_dataset],
    sub_agents=[root_sql_agent]
)

#--------------------------------------new agent ASHISH
import datetime
from zoneinfo import ZoneInfo
def get_weather(city: str) -> dict:
    """Retrieves the current weather report for a specified city.

    Args:
        city (str): The name of the city for which to retrieve the weather report.

    Returns:
        dict: status and result or error msg.
    """
    if city.lower() == "new york":
        return {
            "status": "success",
            "report": (
                "The weather in New York is sunny with a temperature of 25 degrees"
                " Celsius (77 degrees Fahrenheit)."
            ),
        }
    else:
        return {
            "status": "error",
            "error_message": f"Weather information for '{city}' is not available.",
        }


def get_current_time(city: str) -> dict:
    """Returns the current time in a specified city.

    Args:
        city (str): The name of the city for which to retrieve the current time.

    Returns:
        dict: status and result or error msg.
    """

    if city.lower() == "new york":
        tz_identifier = "America/New_York"
    else:
        return {
            "status": "error",
            "error_message": (
                f"Sorry, I don't have timezone information for {city}."
            ),
        }

    tz = ZoneInfo(tz_identifier)
    now = datetime.datetime.now(tz)
    report = (
        f'The current time in {city} is {now.strftime("%Y-%m-%d %H:%M:%S %Z%z")}'
    )
    return {"status": "success", "report": report}


root_weather_agent = Agent(
    name="weather_time_agent",
    model=MODEL_GEMINI_2_0_FLASH,
    description=(
        "Agent to answer questions about the time and weather in a city."
    ),
    instruction=(
        "You are a helpful agent who can answer user questions about the time and weather in a city."
    ),
    tools=[get_weather, get_current_time],)

general_greeting_agent1 = Agent(
    name="general_greeting_agent",
    model=MODEL_GEMINI_2_0_FLASH,
    description=(
        "Agent to answer questions relating to user general query"
    ),
    instruction=(
        """You are a helpful agent who can answer user questions and have a great open conversation.
        You can speak in English, Hindi, or any other language."""
    ),)

general_greeting_agent = Agent(
    name="serena_orchestrator_agent", # Renamed for clarity
    model=MODEL_GEMINI_2_0_FLASH,
    description=(
        "General conversational agent for SERENA. Can answer general questions, "
        "interact with BigQuery, and delegate to specialized A2A agents for time and greetings."
    ),
    instruction=(
        """You are SERENA, a helpful and versatile voice assistant.
        You have the following capabilities:
        1.  Engage in general conversation.
        2.  Answer questions about BigQuery databases using the 'root_sql_agent'.
        3.  Tell the current time by using the 'call_external_tell_time_agent' tool.
        4.  Provide poetic greetings by using the 'call_external_greeting_agent' tool.

        Analyze the user's request:
        - If the user asks for the current time (e.g., "What time is it?"), use the 'call_external_tell_time_agent' tool with the user's exact query.
        - If the user asks for a greeting, especially a poetic one (e.g., "Greet me", "Say hello poetically"), use the 'call_external_greeting_agent' tool with the user's exact query.
        - For database queries (e.g., "How many users?", "Show me orders"), delegate to the 'root_sql_agent'.
        - For other general conversation, respond naturally.
        When using a tool, pass the user's original relevant query as the message to the tool.
        """
    ),
    tools=[
        FunctionTool(call_external_tell_time_agent),
        FunctionTool(call_external_greeting_agent),
        # bq_rdr.list_tables_in_dataset, # Keep if direct BigQuery tools are still desired at this level
    ],
    sub_agents=[
        general_agent # For BigQuery tasks
    ]
    # output_key="final_response" # Optional: if you want to explicitly name the output
)

# Ensure this is the agent used in app/main.py:
# general_agent = general_greeting_agent # If you rename it back or use an alias
# Or, if you keep general_greeting_agent as is and create a new orchestrator, use that.

# You might want to simplify general_greeting_agent if it's ONLY for simple chat
# and create a new top-level orchestrator:
# For example:
# simple_greeting_agent = Agent(name="simple_greeting_agent", ...)
# serena_main_orchestrator = Agent(
#    name="serena_main_orchestrator",
#    tools=[... call_external_tell_time_agent, call_external_greeting_agent],
#    sub_agents=[root_sql_agent, simple_greeting_agent],
#    instruction="Orchestrate between sub_agents and tools..."
# )
# And then in app/main.py, use `serena_main_orchestrator`.
# For now, we've modified general_greeting_agent to take on this role.